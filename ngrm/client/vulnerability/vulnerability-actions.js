import axios from 'axios'
import * as endpoints from '../constants/endpoints'
import * as routes from '../constants/routes'
import * as httpStatus from '../constants/http-status-codes'
import * as types from './vulnerability-action-types'
import * as chartActions from '../components/charts/chart-actions'

export const getItems = dispatch => engagementId => {
  dispatch({ type: types.VULN_GET_ITEMS_FETCHING })
  
  return axios.get(endpoints.VULNERABILITIES + '/' + engagementId)
    .then(r => {
      dispatch({ type: types.VULN_GET_ITEMS_SUCCESS, payload: r.data })
    })
    .catch(e => {
      if (e.response.status !== httpStatus.BAD_REQUEST) return
      dispatch({ type: types.VULN_GET_ITEMS_FAILED, error: e.response.data })
    })
}

export const getGrid = dispatch => (engagementId, table) => {
  if (engagementId) {
    chartActions.getVulnerabilityCharts(dispatch)(engagementId)
    getItems(dispatch)(engagementId)
    table.fetchRows()

    // Make sure to init the import fields every time we get the grid
    handleImportCancel(dispatch)(engagementId)
  }
}

export const get = dispatch => (engagementId, phaseId, vulnId) => {
  dispatch({ type: types.VULN_GET_FETCHING })

  return axios.get(`${endpoints.VULNERABILITIES}/${engagementId}/${phaseId}/${vulnId}`)
    .then(r => dispatch({ type: types.VULN_GET_SUCCESS, payload: r.data }))
    .catch(e => {
      if (e && e.response && e.response.status && e.response.status !== httpStatus.BAD_REQUEST) return
      dispatch({ type: types.VULN_GET_FAILED, error: e.response.data })
    })
}

export const setHistoricalVulns = dispatch => (value) => {
  dispatch({ type: types.VULN_SET_HISTORICAL_VULNS }, value)
}

export const update = dispatch => (details, history) => {
  var data = {
    Id: details.Id,
    EngagementId: details.EngagementId,
    PhaseId: details.PhaseId,
    ResourceId: details.ResourceId,
    GroupId: details.GroupId,
    RemediationStatusId: details.RemediationStatusId,
    MitigationDate: details.MitigationDate,
    TargetRemediationDate: details.TargetRemediationDate
  };

  dispatch({ type: types.VULN_POST_FETCHING })

  return axios.post(endpoints.VULNERABILITIES, data)
    .then(r => {
      dispatch({ type: types.VULN_POST_SUCCESS, payload: r.data })
      history.push(routes.RISK_PAGE_BASE + routes.VULN_PAGE + '/' + details.EngagementId)
    })
    .catch(e => {
      if (e.response.status !== httpStatus.BAD_REQUEST) return
      dispatch({ type: types.VULN_POST_FAILED, validationErrors: e.response.data })
    })
}

export const assignResource = dispatch => (resource, group) => {
  dispatch({ type: types.VULN_RESOURCE_ASSIGN_SAVE, resource, group })
}

export const handlePhaseChange = dispatch => (value) => {
  return dispatch({ type: types.VULN_CHANGE_PHASE, value })
}

export const handleRemediationStatusChange = dispatch => (value) => {
  dispatch({ type: types.VULN_REMEDIATION_STATUS_CHANGE, value })
}

export const handleRemediatedDateSelected = dispatch => (value) => {
  return dispatch({ type: types.VULN_REMEDIATED_DATE_SELECTED, value })
}

export const handleRemediatedDateChange = dispatch => (value) => {
  return dispatch({ type: types.VULN_REMEDIATED_DATE_CHANGE, value })
}

export const handleRemediatedDateClick = dispatch => () => {
  dispatch({ type: types.VULN_REMEDIATED_DATE_CLICK })
}

export const handleRemediatedDateClose = dispatch => (e) => {
  dispatch({ type: types.VULN_REMEDIATED_DATE_CLOSE })
}

export const handleRemediatedDateBlur = dispatch => (e) => {
  dispatch({ type: types.VULN_REMEDIATED_DATE_BLUR })
}

export const handleTargetRemediationDateSelected = dispatch => (value) => {
  return dispatch({ type: types.VULN_SELECT_TARGET_REMEDIATION_DATE, value })
}

export const handleTargetRemediationDateChange = dispatch => (value) => {
  return dispatch({ type: types.VULN_CHANGE_TARGET_REMEDIATION_DATE, value })
}

export const handleTargetRemediationDateClick = dispatch => () => {
  dispatch({ type: types.VULN_CLICK_TARGET_REMEDIATION_DATE })
}

export const handleTargetRemediationDateClose = dispatch => (e) => {
  dispatch({ type: types.VULN_CANCEL_TARGET_REMEDIATION_DATE })
}

export const handleTargetRemediationDateBlur = dispatch => (e) => {
  dispatch({ type: types.VULN_BLUR_TARGET_REMEDIATION_DATE })
}

export const handleExport = dispatch => (event) => {
  dispatch({ type: types.VULN_POST_EXPORT_FETCHING })

  var data = {
    EngagementId: event.engagementId,
    IdList: event.idList,
    Option: event.option
  };

  return axios.post(endpoints.EXPORT_VULNERABILITIES, data)
    .then(r => {
      dispatch({ type: types.VULN_POST_EXPORT_SUCCESS, payload: r.data })
      let url = endpoints.EXPORT_CSV + '/' + r.data.sessionKey + '/' + r.data.fileName
      window.open(url, '_self');
    })
    .catch(e => {
      if (e.response.status !== httpStatus.BAD_REQUEST) return
      dispatch({ type: types.VULN_POST_EXPORT_FAILED, error: e.response.data })
    })
}

export const handleSort = dispatch => (field, comparator) => {
  dispatch({ type: types.VULN_SORT, field, comparator })
}

export const handleFilter = dispatch => (field, value, filter) => {
  dispatch({ type: types.VULN_FILTER, field, value, filter })
}

export const handlePageSizeChange = dispatch => (size) => {
  dispatch({ type: types.VULN_PAGE_SIZE_CHANGE, size })
}

export const handlePageIndexChange = dispatch => (index) => {
  dispatch({ type: types.VULN_PAGE_INDEX_CHANGE, index })
}

export const handleExportDropdownClick = dispatch => () => {
  dispatch({ type: types.VULN_EXPORT_DROPDOWN_CLICK })
}

export const handleExportDropdownMouseLeave = dispatch => () => {
  dispatch({ type: types.VULN_EXPORT_DROPDOWN_MOUSE_LEAVE })
}

export const handleImportClick = dispatch => (engagementId) => {
  return axios.get(endpoints.PHASES + '/' + engagementId)
    .then(r => dispatch({ type: types.VULN_IMPORT_CLICK, payload: r.data }))
}

export const handleImportPhaseChange = dispatch => (value) => {
  dispatch({ type: types.VULN_IMPORT_PHASE_CHANGE, value })
}

export const handleImportFileChange = dispatch => (value) => {
  dispatch({ type: types.VULN_IMPORT_FILE_CHANGE, value })
}

export const handleImportSave = dispatch => (engagementId, form, table) => {
  dispatch({ type: types.VULN_POST_IMPORT_FETCHING })
  let data = new FormData();
  data.append("EngagementId", engagementId);
  data.append("PhaseId", form.phaseId);
  data.append("File", form.file);

  return axios.post(endpoints.IMPORT_VULNERABILITIES, data)
    .then(r => {
      dispatch({ type: types.VULN_POST_IMPORT_SUCCESS, payload: r.data })
      getGrid(dispatch)(engagementId, table)
    })
    .catch(e => {
      if (e.response.status !== httpStatus.BAD_REQUEST) return

      let errorMessage = ""
      if (typeof (e.response.data) === "string") {
        errorMessage = e.response.data
      }

      let fieldErrors = {}
      if (typeof (e.response.data) === "object") {
        fieldErrors = e.response.data
      }

      dispatch({ type: types.VULN_POST_IMPORT_FAILED, errorMessage, fieldErrors })
    })
}

export const handleImportCancel = dispatch => () => {
  dispatch({ type: types.VULN_IMPORT_CANCEL })
}

export const handleImportSummaryClose = dispatch => () => {
  dispatch({ type: types.VULN_IMPORT_SUMMARY_CLOSE })
}

export const handleSelectAll = dispatch => (checked, rows) => {
  dispatch({ type: types.VULN_SELECT_ALL_CLICK, checked, rows })
}

export const handleSelectRow = dispatch => (checked, id, rows) => {
  dispatch({ type: types.VULN_SELECT_ROW_CLICK, checked, id, rows })
}

export const handleSelectedItemActionsDropdownClick = dispatch => () => {
  dispatch({ type: types.VULN_SELECTED_ITEM_ACTIONS_DROPDOWN_CLICK })
}

export const handleSelectedItemActionsDropdownMouseLeave = dispatch => () => {
  dispatch({ type: types.VULN_SELECTED_ITEM_ACTIONS_DROPDOWN_MOUSE_LEAVE })
}

export const handleSelectedItemActionsClear = dispatch => () => {
  dispatch({ type: types.VULN_SELECTED_ITEM_ACTIONS_CLEAR })
}

export const handleSelectedItemActionsCreate = dispatch => (vulnerabilityList, history, engagementId) => {
  dispatch({ type: types.VULN_SELECTED_ITEM_ACTIONS_CREATE })
  history.push({
    pathname: routes.RISK_PAGE_BASE + routes.RISK_PAGE + '/' + engagementId + '/0',
    state: { vulnerabilityList }
  })
}

export const handleSelectedItemActionsAssign = dispatch => (engagementId) => {
  return axios.get(endpoints.RISKS + '/' + engagementId)
    .then(r => {
      let riskList = {}
      r.data.forEach(risk => {
        if (!riskList[risk.Phase])
          riskList[risk.Phase] = []

        riskList[risk.Phase] = [...riskList[risk.Phase], risk]
      });

      dispatch({ type: types.VULN_SELECTED_ITEM_ACTIONS_ASSIGN, payload: riskList })
    })
}

export const handleAssignRiskChange = dispatch => (value) => {
  dispatch({ type: types.VULN_ASSIGN_RISK_CHANGE, value })
}

export const handleAssignRiskCancel = dispatch => (value) => {
  dispatch({ type: types.VULN_ASSIGN_RISK_CANCEL })
}

export const handleAssignRiskSave = dispatch => (form, riskList, selectedVulnerabilities, table) => {
  dispatch({ type: types.VULN_POST_ASSIGN_RISK_FETCHING })

  if (!form.riskId) {
    dispatch({ type: types.VULN_POST_ASSIGN_RISK_FAILED, fieldErrors: { RiskId: ["Required"] } })
    return Promise.resolve()
  }

  let risksById = {}
  Object.keys(riskList)
    .map(key => riskList[key])
    .forEach(risk => {
      risk.forEach(r => { risksById[r.Id] = r })
    })

  let risk = risksById[form.riskId]
  let data = {
    Id: risk.Id,
    EngagementId: risk.EngagementId,
    ImportedDate: risk.ImportedDate,
    ImportedBy: risk.ImportedBy,
    Name: risk.Name,
    PhaseId: risk.PhaseId,
    ResourceId: risk.ResourceId,
    GroupId: risk.GroupId,
    InherentRisk: risk.InherentRisk,
    Likelihood: risk.Likelihood,
    Description: risk.Description,
    Recommendation: risk.Recommendation,
    RemediationStatusId: risk.RemediationStatusId,
    MitigationDate: risk.MitigationDate,
    MitigationStatusId: risk.MitigationStatusId,
    AffectedSystemsCount: risk.AffectedSystemsCount,
    PossibleAffectedSystemsCount: risk.PossibleAffectedSystemsCount,
    Effectiveness: risk.Effectiveness,
    ControlEffectiveness: risk.ControlEffectiveness,
    Impact: risk.Impact,
    RiskScore: risk.RiskScore,
    References: risk.References,
    VulnerabilityList: [...risk.VulnerabilityList, ...selectedVulnerabilities]
  }

  return axios.post(endpoints.RISKS, data)
    .then(r => {
      dispatch({ type: types.VULN_POST_ASSIGN_RISK_SUCCESS })
      getGrid(dispatch)(risk.EngagementId, table)
    })
    .catch(e => {
      if (e.response.status !== httpStatus.BAD_REQUEST) return

      let fieldErrors = {}
      if (typeof (e.response.data) === "object") {
        fieldErrors = e.response.data
      }

      dispatch({ type: types.VULN_POST_ASSIGN_RISK_FAILED, fieldErrors })
    })
}

export const handleHostsSort = dispatch => (field, comparator) => {
  dispatch({ type: types.VULN_HOSTS_SORT, field, comparator })
}

export const handleHostsFilter = dispatch => (field, value, filter) => {
  dispatch({ type: types.VULN_HOSTS_FILTER, field, value, filter })
}

export const handleHostsPageSizeChange = dispatch => (size) => {
  dispatch({ type: types.VULN_HOSTS_PAGE_SIZE_CHANGE, size })
}

export const handleHostsPageIndexChange = dispatch => (index) => {
  dispatch({ type: types.VULN_HOSTS_PAGE_INDEX_CHANGE, index })
}

export const handleHistoryButtonToggle = dispatch => () => {
  dispatch({ type: types.VULN_DETAIL_HISTORY_BUTTON_TOGGLE})
}